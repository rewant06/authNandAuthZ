generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum PermissionAction {
  CREATE
  READ
  UPDATE
  DELETE
  MANAGE // ALL
}

enum AuditAction {
  AUTH_LOGIN_ATTEMPT
  AUTH_LOGIN_SUCCESS
  AUTH_LOGIN_FAILED
  AUTH_LOGIN_LOCKED
  AUTH_REFRESH_REUSED
  AUTH_REFRESH_REUSE_DETECTED
  AUTH_REFRESH_SUCCESS
  PASSWORD_RESET_REQUEST
  PASSWORD_RESET_SUCCESS
  PASSWORD_RESET_FAILED
  AUTH_REFRESH_REVOKE
}

model User {
  id             String         @id @default(cuid())
  email          String         @unique
  name           String?
  roles           Role[]
  hashedPassword String?
  auditEvents    AuditEvent[]
  refreshTokens  RefreshToken[]
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
}

model Role {
  id          String       @id @default(cuid())
  name        String       @unique // e.g., "ADMIN", "USER", "MODERATOR"
  description String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // A role can be assigned to many users
  users       User[]
  // A role has many permissions
  permissions Permission[]
}

model Permission {
  id        String   @id @default(cuid())
  action    PermissionAction
  // The subject: e.g., "User", "AuditLog", "Comment"
  // We use "all" to represent "any subject" (e.g., for a super-admin)
  subject   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A permission can be granted to many roles
  roles     Role[]

  @@unique([action, subject]) // Ensure "READ:User" can only exist once
}

model AuditEvent {
  id        String      @id @default(cuid())
  userId    String?
  user      User?       @relation(fields: [userId], references: [id])
  email     String?
  action    AuditAction
  success   Boolean     @default(false)
  reason    String?
  ip        String?
  device    String?
  meta      Json?
  timestamp DateTime    @default(now())
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  @@index([action, createdAt])
  @@index([success, createdAt])
}

model RefreshToken {
  id         Int       @id @default(autoincrement())
  tokenHash  String
  userId     String
  user       User      @relation(fields: [userId], references: [id])
  createdAt  DateTime  @default(now())
  expiresAt  DateTime
  revokedAt  DateTime?
  revoked    Boolean   @default(false)
  device     String?
  replacedBy Int? // to store id of replacing token
  lastUsedAt DateTime?
}
